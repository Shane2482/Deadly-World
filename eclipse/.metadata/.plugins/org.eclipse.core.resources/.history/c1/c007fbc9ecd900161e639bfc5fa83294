package shane2482.deadlyworld.render;

import java.util.Random;

import org.lwjgl.opengl.GL11;

import com.google.common.primitives.SignedBytes;

import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.client.model.ModelChest;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.entity.RenderEntityItem;
import net.minecraft.client.renderer.tileentity.TileEntitySpecialRenderer;
import net.minecraft.item.ItemStack;
import net.minecraft.util.ResourceLocation;
import shane2482.deadlyworld.Reference;
import shane2482.deadlyworld.tiles.TileEntityBasaltChest;

public class BasaltChestRenderer extends TileEntitySpecialRenderer<TileEntityBasaltChest> {

	ResourceLocation Basalt_Chest = new ResourceLocation(
			Reference.MOD_ID + ":" + "textures/entity/chest/plywood_chest.png");
	private ModelChest model;
	private RenderEntityItem itemRenderer;
	private Random random;

	public BasaltChestRenderer() {
		this.model = new ModelChest();
		

	}

	@Override
	public void renderTileEntityAt(TileEntityBasaltChest te, double x, double y, double z, float partialTicks,
			int destroyStage) {
		int facing = 3;
		

		
		
		
		if (te instanceof TileEntityBasaltChest) {
			TileEntityBasaltChest mod_chest = (TileEntityBasaltChest) te;

			GlStateManager.pushMatrix();
			IBlockState state = mod_chest.getWorld().getBlockState(mod_chest.getPos());
			switch (state.getBlock().getMetaFromState(state)) {
			case 1:
				GlStateManager.rotate(0, 0, 0, 0);
				break;
			// Facing South
			case 2:
			
		        float lidangle = te.prevLidAngle + (te.lidAngle - te.prevLidAngle) * partialTicks;
		        lidangle = 1.0F - lidangle;
		        lidangle = 1.0F - lidangle * lidangle * lidangle;
		        model.chestLid.rotateAngleX = -((lidangle * 3.141593F) / 2.0F);
				GL11.glTranslatef((float) x + 1.0f, (float) y + 1.0f, (float) z + 0.0f);
				GlStateManager.rotate(180, 0, 0, 1);
				break;
			// Facing North
			case 3:
				float lidangle1 = te.prevLidAngle + (te.lidAngle - te.prevLidAngle) * partialTicks;
				lidangle1 = 1.0F - lidangle1;
				lidangle1 = 1.0F - lidangle1 * lidangle1 * lidangle1;
		        model.chestLid.rotateAngleX = -((lidangle1 * 3.141593F) / 2.0F);
				GL11.glTranslatef((float) x + 0.0f, (float) y + 1.0f, (float) z + 1.0f);
				GlStateManager.rotate(180, -180, 0, 1);
				break;
			// Facing East
			case 4:
				float lidangle2 = te.prevLidAngle + (te.lidAngle - te.prevLidAngle) * partialTicks;
		        lidangle2 = 1.0F - lidangle2;
		        lidangle2 = 1.0F - lidangle2 * lidangle2 * lidangle2;
		        model.chestLid.rotateAngleX = -((lidangle2 * 3.141593F) / 2.0F);
				GL11.glTranslatef((float) x + 0.0f, (float) y + 1.0f, (float) z + 0.0f);
				GlStateManager.rotate(180, 1, 0, 1);
				break;
			// Facing West
			case 5:
				float lidangle3 = te.prevLidAngle + (te.lidAngle - te.prevLidAngle) * partialTicks;
		        lidangle3 = 1.0F - lidangle3;
		        lidangle3 = 1.0F - lidangle3 * lidangle3 * lidangle3;
		        model.chestLid.rotateAngleX = -((lidangle3 * 3.141593F) / 2.0F);
				GL11.glTranslatef((float) x + 1.0f, (float) y + 1.0f, (float) z + 1.0f);
				GlStateManager.rotate(180, -1, 0, 1);
				break;
			}
			
	           
	       
	        
			this.bindTexture(Basalt_Chest);
			GL11.glPushMatrix();
			this.model.renderAll();
			GL11.glPopMatrix();
			GL11.glPopMatrix();
		}
	}

}