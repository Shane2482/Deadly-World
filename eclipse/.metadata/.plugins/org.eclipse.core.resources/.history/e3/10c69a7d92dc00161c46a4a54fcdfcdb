package shane2482.deadlyworld.wip;

import javax.annotation.Nullable;

import net.minecraft.block.Block;
import net.minecraft.block.BlockFurnace;
import net.minecraft.block.material.Material;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.inventory.IInventory;
import net.minecraft.inventory.ISidedInventory;
import net.minecraft.inventory.ItemStackHelper;
import net.minecraft.inventory.SlotFurnaceFuel;
import net.minecraft.item.Item;
import net.minecraft.item.ItemBlock;
import net.minecraft.item.ItemHoe;
import net.minecraft.item.ItemStack;
import net.minecraft.item.ItemSword;
import net.minecraft.item.ItemTool;
import net.minecraft.item.crafting.FurnaceRecipes;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.datafix.DataFixer;
import net.minecraft.util.datafix.FixTypes;
import net.minecraft.util.datafix.walkers.ItemStackDataLists;
import net.minecraft.util.math.MathHelper;

public class TileEntityModFurnace extends TileEntity implements IInventory, ISidedInventory {

	private int power;
	public int cookTime;

	private int furnaceBurnTime;
	private int currentItemBurnTime;
	private int totalCookTime;

	public static final int maxFuel = 10000;
	

	private String name;
	private ItemStack slots[];
	private static final int[] slots_top = new int[] { 0, 1 };
	private static final int[] slots_bottom = new int[] { 3, 4 };
	private static final int[] slots_sides = new int[] { 2 };

	public static final int input1 = 0;

	public static final int input2 = 1;

	public static final int fuel1 = 2;

	public static final int output1 = 3;

	public static final int output2 = 4;

	public int firstSmeltTime;
	public int secondSmeltTime;
	

	   public TileEntityModFurnace() {
		slots = new ItemStack[5];
		
		
	} 
	   
	   public int getCookTime(@Nullable ItemStack stack)
	    {
	        return 200;
	    }
	    
	@Override
	public String getName() {
		return this.hasCustomName() ? this.name : "container.basaltfurnace";
	}

	@Override
	public boolean hasCustomName() {
		return this.name != null && this.name.length() > 0;
	}

	public void setCustomName(String name) {
		this.name = name;
	}

	@Override
	public int getSizeInventory() {
		return slots.length;
	}

	@Override
	public ItemStack getStackInSlot(int index) {
		return slots[index];
	}

	@Override
	@Nullable
	public ItemStack decrStackSize(int index, int count) {
		return ItemStackHelper.getAndSplit(this.slots, index, count);
	}

	@Override
	@Nullable
	public ItemStack removeStackFromSlot(int index) {
		return ItemStackHelper.getAndRemove(this.slots, index);
	}

	@Override
	public void setInventorySlotContents(int index, ItemStack stack) {
		
        this.slots[index] = stack;

        if (stack != null && stack.stackSize > this.getInventoryStackLimit())
        {
            stack.stackSize = this.getInventoryStackLimit();
        }
       
    }
	
	

	@Override
	public int getInventoryStackLimit() {
		return 64;
	}

	@Override
	public boolean isUseableByPlayer(EntityPlayer player) {
		if (worldObj.getTileEntity(pos) != this) {
			return false;
		} else {
			return player.getDistanceSq((double) this.pos.getX() + 0.5D, (double) this.pos.getY() + 0.5D,
					(double) this.pos.getZ() + 0.5D) <= 64.0D;
		}
	}

	
	public void openInventory(EntityPlayer player) {}
	public void closeInventory(EntityPlayer player) {}

	@Override
	public boolean isItemValidForSlot(int index, ItemStack stack) {
		ItemStack FuelSlot = slots[fuel1];
		
		if (index == output1)
	        {
	            return false;
	        } else if (index == output2)
	        {
	            return false;
	        }
	        else if (index != fuel1)
	        {
	            return true;
	        }
	        else
	        {
	            ItemStack itemstack = FuelSlot;
	            return isItemFuel(stack) || SlotFurnaceFuel.isBucket(stack) && (itemstack == null || itemstack.getItem() != Items.BUCKET);
	        }
	}

	public static boolean isItemFuel(ItemStack stack) {
		return getItemBurnTime(stack) > 0;
	}

	public static int getItemBurnTime(ItemStack stack) {
		if (stack == null) {
			return 0;
		} else {
			Item item = stack.getItem();

			if (item instanceof ItemBlock && Block.getBlockFromItem(item) != Blocks.AIR) {
				Block block = Block.getBlockFromItem(item);

				if (block == Blocks.WOODEN_SLAB) {
					return 150;
				}

				if (block.getDefaultState().getMaterial() == Material.WOOD) {
					return 300;
				}

				if (block == Blocks.COAL_BLOCK) {
					return 16000;
				}
			}

			if (item instanceof ItemTool && "WOOD".equals(((ItemTool) item).getToolMaterialName()))
				return 200;
			if (item instanceof ItemSword && "WOOD".equals(((ItemSword) item).getToolMaterialName()))
				return 200;
			if (item instanceof ItemHoe && "WOOD".equals(((ItemHoe) item).getMaterialName()))
				return 200;
			if (item == Items.STICK)
				return 100;
			if (item == Items.COAL)
				return 1600;
			if (item == Items.LAVA_BUCKET)
				return 20000;
			if (item == Item.getItemFromBlock(Blocks.SAPLING))
				return 100;
			if (item == Items.BLAZE_ROD)
				return 2400;
			return net.minecraftforge.fml.common.registry.GameRegistry.getFuelValue(stack);
		}
	}

	@Override
	public int getField(int id) {
		 switch (id)
	        {
	            case 0:
	                return this.furnaceBurnTime;
	            case 1:
	                return this.currentItemBurnTime;
	            case 2:
	                return this.cookTime;
	            case 3:
	                return this.totalCookTime;
	            case 4:
	            	return this.power;
	            default:
	                return 0;
	        }
	    }

	@Override
	public void setField(int id, int value) {
		switch (id)
        {
            case 0:
                this.furnaceBurnTime = value;
                break;
            case 1:
                this.currentItemBurnTime = value;
                break;
            case 2:
                this.cookTime = value;
                break;
            case 3:
                this.totalCookTime = value;
            case 4:
            	this.power = value;
        }
    }

	@Override
	public int getFieldCount() {
		
		return 5;
	}

	@Override
	public void clear()  {
        for (int i = 0; i < this.slots.length; ++i)
        {
            this.slots[i] = null;
        }
    }

	public NBTTagCompound writeToNBT(NBTTagCompound compound) {
		super.writeToNBT(compound);
		compound.setShort("Fuel", (short)power);
		compound.setShort("CookTime", (short)cookTime);
		// compound.setInteger("CookTimeTotal", this.totalCookTime);
		NBTTagList list = new NBTTagList();

		for (int i = 0; i < this.slots.length; ++i) {
			if (this.slots[i] != null) {
				NBTTagCompound compound1 = new NBTTagCompound();
				compound1.setByte("Slot", (byte) i);
				this.slots[i].writeToNBT(compound1);
				list.appendTag(compound1);
			}
		}

		compound.setTag("Items", list);

		if (this.hasCustomName()) {
			compound.setString("CustomName", this.name);
		}

		return compound;
	}

	public void readFromNBT(NBTTagCompound compound) {
		super.readFromNBT(compound);
		NBTTagList list = compound.getTagList("Items", 10);
		this.slots = new ItemStack[this.getSizeInventory()];

		for (int i = 0; i < list.tagCount(); ++i) {
			NBTTagCompound compound1 = list.getCompoundTagAt(i);
			int j = compound1.getByte("Slot");

			if (j >= 0 && j < this.slots.length) {
				this.slots[j] = ItemStack.loadItemStackFromNBT(compound1);
			}
		}

		// this.furnaceBurnTime = compound.getInteger("BurnTime");
		this.cookTime = compound.getShort("CookTime");
		this.power = compound.getShort("Fuel");
		// this.totalCookTime = compound.getInteger("CookTimeTotal");
		// this.currentItemBurnTime = getItemBurnTime(this.slots[1]);

		if (compound.hasKey("CustomName", 8)) {
			this.name = compound.getString("CustomName");
		}
	}

	public static void registerFixesFurnace(DataFixer fixer) {
		fixer.registerWalker(FixTypes.BLOCK_ENTITY, new ItemStackDataLists("block_basalt_furnace", new String[] { "Items" }));
	}

	@Override
	public int[] getSlotsForFace(EnumFacing side)
    {
        return side == EnumFacing.DOWN ? slots_bottom : (side == EnumFacing.UP ? slots_top : slots_sides);
    }

	@Override
	public boolean canInsertItem(int index, ItemStack stack, EnumFacing direction) {
		 return this.isItemValidForSlot(index, stack);
   }

	@Override
	public boolean canExtractItem(int index, ItemStack stack, EnumFacing direction){
        if (direction == EnumFacing.DOWN && index == 1)
        {
            Item item = stack.getItem();

            if (item != Items.WATER_BUCKET && item != Items.BUCKET)
            {
                return false;
            }
        }

        return true;
    }
	
	public void setCustomInventoryName(String name)
	    {
			this.name = name;
	    }
	
	/*public int getProgreressScaled(int i){
		return (cookTime * i) / this.cookSpeed;
	}*/
	
	public int getFuelRemainingScaled(int i){
		return (power * i) / maxFuel;
	}
	
	
	
	
		 private boolean canSmelt1()
		    {
			 
			 ItemStack FuelSlot = slots[fuel1];
			ItemStack InputSlot1 = slots[input1];
			if (InputSlot1 == null)
		        {
		            return false;
		        }
		        else
		        {
		            ItemStack itemstack = FurnaceRecipes.instance().getSmeltingResult(InputSlot1);
		            if (itemstack == null) return false;
		            if (FuelSlot == null) return true;
		            if (!FuelSlot.isItemEqual(itemstack)) return false;
		            int result = FuelSlot.stackSize + itemstack.stackSize;
		            return result <= getInventoryStackLimit() && result <= FuelSlot.getMaxStackSize(); //Forge BugFix: Make it respect stack sizes properly.
		        }
		    }
    
	
		 public void smeltItem1()
		    {
			 	ItemStack FuelSlot = slots[fuel1];
				ItemStack InputSlot1 = slots[input1];
				ItemStack OutputSlot1 = slots[output1];
		        if (this.canSmelt1())
		        {
		            ItemStack itemstack = FurnaceRecipes.instance().getSmeltingResult(InputSlot1);

		            if (OutputSlot1 == null)
		            {
		            	OutputSlot1 = itemstack.copy();
		            }
		            else if (OutputSlot1.getItem() == itemstack.getItem())
		            {
		                OutputSlot1.stackSize += itemstack.stackSize; // Forge BugFix: Results may have multiple items
		            }

		            if (InputSlot1.getItem() == Item.getItemFromBlock(Blocks.SPONGE) && InputSlot1.getMetadata() == 1 && FuelSlot != null && FuelSlot.getItem() == Items.BUCKET)
		            {
		            	FuelSlot = new ItemStack(Items.WATER_BUCKET);
		            }

		            --InputSlot1.stackSize;

		            if (InputSlot1.stackSize <= 0)
		            {
		            	InputSlot1 = null;
		            }
		        }
		    }
	
	
	
	
	private boolean isBurning() {
		return this.furnaceBurnTime > 0;
	}
	 
	public void update()
    {
		
		ItemStack FuelSlot = slots[fuel1];
		ItemStack InputSlot1 = slots[input1];
        boolean flag = this.isBurning();
        boolean flag1 = false;

        if (this.isBurning())
        {
            --this.furnaceBurnTime;
        }

        if (!this.worldObj.isRemote)
        {
            if (this.isBurning() || FuelSlot != null && InputSlot1 != null)
            {
                if (!this.isBurning() && this.canSmelt1())
                {
                    this.furnaceBurnTime = getItemBurnTime(FuelSlot);
                    this.currentItemBurnTime = this.furnaceBurnTime;

                    if (this.isBurning())
                    {
                        flag1 = true;

                        if (FuelSlot != null)
                        {
                            --FuelSlot.stackSize;

                            if (FuelSlot.stackSize == 0)
                            {
                                FuelSlot = FuelSlot.getItem().getContainerItem(FuelSlot);
                            }
                        }
                    }
                }

                if (this.isBurning() && this.canSmelt1())
                {
                    ++this.cookTime;

                    if (this.cookTime == this.totalCookTime)
                    {
                        this.cookTime = 0;
                        this.totalCookTime = this.getCookTime(InputSlot1);
                        this.smeltItem1();
                        flag1 = true;
                    }
                }
                else
                {
                    this.cookTime = 0;
                }
            }
            else if (!this.isBurning() && this.cookTime > 0)
            {
                this.cookTime = MathHelper.clamp_int(this.cookTime - 2, 0, this.totalCookTime);
            }

            if (flag != this.isBurning())
            {
                flag1 = true;
                BlockFurnace.setState(this.isBurning(), this.worldObj, this.pos);
            }
        }

        if (flag1)
        {
            this.markDirty();
        }
    }
}
