package shane2482.deadlyworld.blocks;

import java.util.List;

import javax.annotation.Nullable;

import Shane2482.DeadlyWorld.blocks.base.item_blocks;
import net.minecraft.block.Block;
import net.minecraft.block.BlockContainer;
import net.minecraft.block.material.Material;
import net.minecraft.block.properties.IProperty;
import net.minecraft.block.properties.PropertyDirection;
import net.minecraft.block.state.BlockStateContainer;
import net.minecraft.block.state.IBlockState;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.passive.EntityOcelot;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.inventory.Container;
import net.minecraft.inventory.IInventory;
import net.minecraft.inventory.InventoryHelper;
import net.minecraft.item.ItemStack;
import net.minecraft.stats.StatList;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.EnumBlockRenderType;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.Mirror;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.IBlockAccess;
import net.minecraft.world.ILockableContainer;
import net.minecraft.world.World;
import net.minecraftforge.fml.common.registry.GameRegistry;
import shane2482.deadlyworld.DeadlyWorld;
import shane2482.deadlyworld.handlers.GuiHandler;
import shane2482.deadlyworld.tiles.TileEntityBasaltChest;

public class block_basalt_chest extends BlockContainer {

	private String name;
	public static final PropertyDirection Facing = PropertyDirection.create("facing", EnumFacing.Plane.HORIZONTAL);
	//0.0625
	private static final AxisAlignedBB Bounding_Box = new AxisAlignedBB(0.0625 * 1 , 0, 0.0625 * 1, 0.0625 * 15, 0.0625 * 14, 0.0625 * 15);
	
	
	
	public block_basalt_chest(Material material, String name, String Regname) {
		super(material);
		setUnlocalizedName(name);
		setRegistryName(Regname);
		this.name = name;
		this.setCreativeTab(DeadlyWorld.block);
		this.register();
	

	}
	
	@Override
	public AxisAlignedBB getBoundingBox(IBlockState state, IBlockAccess source, BlockPos pos) {
		
		return Bounding_Box;
	}
	
	@Override
	 public void addCollisionBoxToList(IBlockState state, World worldIn, BlockPos pos, AxisAlignedBB entityBox, List<AxisAlignedBB> collidingBoxes, @Nullable Entity entityIn)
    {
        addCollisionBoxToList(pos, entityBox, collidingBoxes, Bounding_Box);
       
    }
	
	////////////// Facing
	@Override
	public void onBlockAdded(World world, BlockPos pos, IBlockState state) {
		this.setDefaltFacing(world, pos, state);
	}

	private void setDefaltFacing(World world, BlockPos pos, IBlockState state) {
		if (!world.isRemote) {
			IBlockState blockstate0 = world.getBlockState(pos.north());
			IBlockState blockstate1 = world.getBlockState(pos.south());
			IBlockState blockstate2 = world.getBlockState(pos.east());
			IBlockState blockstate3 = world.getBlockState(pos.west());
			EnumFacing enumfacing = (EnumFacing) state.getValue(Facing);

			if (enumfacing == EnumFacing.NORTH && blockstate0.isFullBlock() && blockstate1.isFullBlock()) {
				enumfacing = EnumFacing.SOUTH;
			}
			if (enumfacing == EnumFacing.SOUTH && blockstate1.isFullBlock() && blockstate0.isFullBlock()) {
				enumfacing = EnumFacing.NORTH;
			}
			if (enumfacing == EnumFacing.EAST && blockstate2.isFullBlock() && blockstate3.isFullBlock()) {
				enumfacing = EnumFacing.WEST;
			}
			if (enumfacing == EnumFacing.WEST && blockstate3.isFullBlock() && blockstate2.isFullBlock()) {
				enumfacing = EnumFacing.EAST;
			}
			world.setBlockState(pos, state.withProperty(Facing, enumfacing), 2);
		}

	}

	@Override
	public IBlockState onBlockPlaced(World world, BlockPos pos, EnumFacing facing, float hitX, float hitY, float hitZ,
			int meta, EntityLivingBase placer) {
		return this.getDefaultState().withProperty(Facing, placer.getHorizontalFacing().getOpposite());
	}

	public IBlockState getStateFromMeta(int meta) {
		EnumFacing enumfacing = EnumFacing.getFront(meta);

		if (enumfacing.getAxis() == EnumFacing.Axis.Y) {
			enumfacing = EnumFacing.NORTH;
		}

		return this.getDefaultState().withProperty(Facing, enumfacing);
		
	}

	public int getMetaFromState(IBlockState state) {
		return ((EnumFacing) state.getValue(Facing)).getIndex();
		 
	}

	@Override
	protected BlockStateContainer createBlockState() {
		return new BlockStateContainer(this, new IProperty[] { Facing });
	}
	@Override
	public IBlockState withMirror(IBlockState state, Mirror mirrorIn)
    {
        return state.withRotation(mirrorIn.toRotation((EnumFacing)state.getValue(Facing)));
    }

    
	
	////////////// Drop Items
	 public void breakBlock(World world, BlockPos pos, IBlockState state)
	    {
	        TileEntityBasaltChest tileentity = (TileEntityBasaltChest) world.getTileEntity(pos);

	        if (tileentity instanceof IInventory)
	        {
	            InventoryHelper.dropInventoryItems(world, pos, (IInventory)tileentity);
	            world.updateComparatorOutputLevel(pos, this);
	        }

	        super.breakBlock(world, pos, state);
	    }

	////////////// Render Type
	@Override
	public boolean isOpaqueCube(IBlockState state) {
		return false;
	}

	@Override
	public boolean isFullCube(IBlockState state) {
		return false;
	}

	@Override
	public EnumBlockRenderType getRenderType(IBlockState state) {
		return EnumBlockRenderType.ENTITYBLOCK_ANIMATED;
	}

	@Override
	public TileEntity createNewTileEntity(World world, int meta) {
		return new TileEntityBasaltChest();
	}

	////////////// Register

	private void register() {
		registerBlock(this, this.getItemBlocks(), this.getName());

		
	}

	public static void registerBlock(Block block, item_blocks itemBlock, String name) {

		GameRegistry.register(block);
		itemBlock.setRegistryName(block.getRegistryName());
		GameRegistry.register(itemBlock);
	}

	protected String getName() {
		return this.name;
	}

	protected item_blocks getItemBlocks() {
		return new item_blocks(this);
	}

	
	
	
	public boolean onBlockActivated(World world, BlockPos pos, IBlockState state, EntityPlayer player, EnumHand hand, @Nullable ItemStack heldItem, EnumFacing side, float hitX, float hitY, float hitZ)
	{
		if (world.isRemote) {
			return true;
		} else if (!player.isSneaking()) {
			ILockableContainer ilockablecontainer = this.getLockableContainer(world, pos);

            if (ilockablecontainer != null)
            {
                player.openGui(DeadlyWorld.instance, GuiHandler.Basalt_Chest, world, pos.getX(), pos.getY(), pos.getZ());
                player.addStat(StatList.CHEST_OPENED);
            } 
			return true;
		}else{
			return false;
		}
	}

    @Nullable
    public ILockableContainer getLockableContainer(World world, BlockPos pos)
    {
        return this.getContainer(world, pos, false);
    }

    
   
    
    @Nullable
    public ILockableContainer getContainer(World world, BlockPos pos, boolean bool)
    {
    	TileEntityBasaltChest tileentity = (TileEntityBasaltChest) world.getTileEntity(pos);

        if (!(tileentity instanceof TileEntityBasaltChest))
        {
            return null;
        }
        else
        {
            ILockableContainer ilockablecontainer = (TileEntityBasaltChest)tileentity;

            if (!bool && this.isBlocked(world, pos))
            {
                return null;
            }
            else
            {
                for (EnumFacing enumfacing : EnumFacing.Plane.HORIZONTAL)
                {
                    BlockPos blockpos = pos.offset(enumfacing);
                    Block block = world.getBlockState(blockpos).getBlock();

                    if (block == this)
                    {
                        if (this.isBlocked(world, blockpos))
                        {
                            return null;
                        }

                    }
                }

                return ilockablecontainer;
            }
        }
    }
    
    private boolean isBlocked(World world, BlockPos pos)
    {
        return this.isBelowSolidBlock(world, pos) || this.isOcelotSittingOnChest(world, pos);
    }

    private boolean isBelowSolidBlock(World world, BlockPos pos)
    {
        return world.getBlockState(pos.up()).isSideSolid(world, pos.up(), EnumFacing.DOWN);
    }

    private boolean isOcelotSittingOnChest(World world, BlockPos pos)
    {
        for (Entity entity : world.getEntitiesWithinAABB(EntityOcelot.class, new AxisAlignedBB((double)pos.getX(), (double)(pos.getY() + 1), (double)pos.getZ(), (double)(pos.getX() + 1), (double)(pos.getY() + 2), (double)(pos.getZ() + 1))))
        {
            EntityOcelot entityocelot = (EntityOcelot)entity;

            if (entityocelot.isSitting())
            {
                return true;
            }
        }

        return false;
    }

    public boolean hasComparatorInputOverride(IBlockState state)
    {
        return true;
    }

    public int getComparatorInputOverride(IBlockState blockState, World world, BlockPos pos)
    {
        return Container.calcRedstoneFromInventory(this.getLockableContainer(world, pos));
    }
    
   
       
    
    
	
}	
    

